// Code generated by protoc-gen-gogo.
// source: flow.proto
// DO NOT EDIT!

/*
	Package pipelinepb is a generated protocol buffer package.

	It is generated from these files:
		flow.proto
		pod.proto

	It has these top-level messages:
		FlowIn
		FlowOut
		Link
		Stub
		ManualTrigger
		WebhookTrigger
		CronTrigger
		Pipe
		PodServiceAction
		PodServiceConnection
		PodService
		Execution
		TestRequest
		TestResponse
*/
package pipelinepb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import apipb "github.com/otsimo/otsimopb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Feed int32

const (
	Feed_SINGLE Feed = 0
	Feed_FANOUT Feed = 1
	Feed_FANIN  Feed = 2
)

var Feed_name = map[int32]string{
	0: "SINGLE",
	1: "FANOUT",
	2: "FANIN",
}
var Feed_value = map[string]int32{
	"SINGLE": 0,
	"FANOUT": 1,
	"FANIN":  2,
}

func (x Feed) String() string {
	return proto.EnumName(Feed_name, int32(x))
}
func (Feed) EnumDescriptor() ([]byte, []int) { return fileDescriptorFlow, []int{0} }

type Link_Kind int32

const (
	Link_DIRECT Link_Kind = 0
	Link_SCRIPT Link_Kind = 1
)

var Link_Kind_name = map[int32]string{
	0: "DIRECT",
	1: "SCRIPT",
}
var Link_Kind_value = map[string]int32{
	"DIRECT": 0,
	"SCRIPT": 1,
}

func (x Link_Kind) String() string {
	return proto.EnumName(Link_Kind_name, int32(x))
}
func (Link_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorFlow, []int{2, 0} }

type Execution_State int32

const (
	// Execution not started
	Execution_NOT_STARTED Execution_State = 0
	// Execution is started and waiting to complete
	Execution_RUNNING Execution_State = 1
	// Execution is completed,
	Execution_COMPLETED Execution_State = 2
	// Execution is failed and will retry
	Execution_FAILED Execution_State = 3
)

var Execution_State_name = map[int32]string{
	0: "NOT_STARTED",
	1: "RUNNING",
	2: "COMPLETED",
	3: "FAILED",
}
var Execution_State_value = map[string]int32{
	"NOT_STARTED": 0,
	"RUNNING":     1,
	"COMPLETED":   2,
	"FAILED":      3,
}

func (x Execution_State) String() string {
	return proto.EnumName(Execution_State_name, int32(x))
}
func (Execution_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorFlow, []int{11, 0} }

type FlowIn struct {
	// Payload comes from previous stub or link
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// Data is a dataset created by analytics service
	Data *apipb.DataSet `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	// IDs keeps ids like user_id, child_id, comes from previous stup
	Ids map[string]string `protobuf:"bytes,3,rep,name=ids" json:"ids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Config is special to a stub
	Config []byte `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	// Action
	Action string `protobuf:"bytes,5,opt,name=action,proto3" json:"action,omitempty"`
	// TimestampNano is the UTC start time of pipeline in UnixNano
	TimestampNano int64 `protobuf:"varint,6,opt,name=timestamp_nano,json=timestampNano,proto3" json:"timestamp_nano,omitempty"`
}

func (m *FlowIn) Reset()                    { *m = FlowIn{} }
func (m *FlowIn) String() string            { return proto.CompactTextString(m) }
func (*FlowIn) ProtoMessage()               {}
func (*FlowIn) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{0} }

type FlowOut struct {
	// Payload goes to next stub
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// Data is a dataset created by analytics service
	Data *apipb.DataSet `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	// IDs keeps ids like user_id, child_id, it passes to next stup
	Ids map[string]string `protobuf:"bytes,3,rep,name=ids" json:"ids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlowOut) Reset()                    { *m = FlowOut{} }
func (m *FlowOut) String() string            { return proto.CompactTextString(m) }
func (*FlowOut) ProtoMessage()               {}
func (*FlowOut) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{1} }

type Link struct {
	Kind      Link_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=otsimo.Link_Kind" json:"kind,omitempty"`
	Script    []byte    `protobuf:"bytes,2,opt,name=script,proto3" json:"script,omitempty"`
	LinksFrom string    `protobuf:"bytes,3,opt,name=links_from,json=linksFrom,proto3" json:"links_from,omitempty"`
}

func (m *Link) Reset()                    { *m = Link{} }
func (m *Link) String() string            { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()               {}
func (*Link) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{2} }

type Stub struct {
	StubName      string `protobuf:"bytes,1,opt,name=stub_name,json=stubName,proto3" json:"stub_name,omitempty"`
	ServiceName   string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	ServiceAction string `protobuf:"bytes,3,opt,name=service_action,json=serviceAction,proto3" json:"service_action,omitempty"`
	Config        []byte `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	Feed          Feed   `protobuf:"varint,5,opt,name=feed,proto3,enum=otsimo.Feed" json:"feed,omitempty"`
	Link          *Link  `protobuf:"bytes,6,opt,name=link" json:"link,omitempty"`
}

func (m *Stub) Reset()                    { *m = Stub{} }
func (m *Stub) String() string            { return proto.CompactTextString(m) }
func (*Stub) ProtoMessage()               {}
func (*Stub) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{3} }

type ManualTrigger struct {
}

func (m *ManualTrigger) Reset()                    { *m = ManualTrigger{} }
func (m *ManualTrigger) String() string            { return proto.CompactTextString(m) }
func (*ManualTrigger) ProtoMessage()               {}
func (*ManualTrigger) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{4} }

type WebhookTrigger struct {
}

func (m *WebhookTrigger) Reset()                    { *m = WebhookTrigger{} }
func (m *WebhookTrigger) String() string            { return proto.CompactTextString(m) }
func (*WebhookTrigger) ProtoMessage()               {}
func (*WebhookTrigger) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{5} }

type CronTrigger struct {
	Schedule string `protobuf:"bytes,1,opt,name=schedule,proto3" json:"schedule,omitempty"`
}

func (m *CronTrigger) Reset()                    { *m = CronTrigger{} }
func (m *CronTrigger) String() string            { return proto.CompactTextString(m) }
func (*CronTrigger) ProtoMessage()               {}
func (*CronTrigger) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{6} }

type Pipe struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Trigger:
	//	*Pipe_Manual
	//	*Pipe_Webhook
	//	*Pipe_Cron
	Trigger      isPipe_Trigger `protobuf_oneof:"trigger"`
	SuccessCount int32          `protobuf:"varint,6,opt,name=success_count,json=successCount,proto3" json:"success_count,omitempty"`
	ErrorCount   int32          `protobuf:"varint,7,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	Disabled     bool           `protobuf:"varint,8,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Stubs        []*Stub        `protobuf:"bytes,9,rep,name=stubs" json:"stubs,omitempty"`
	CreatedAt    int64          `protobuf:"varint,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt    int64          `protobuf:"varint,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *Pipe) Reset()                    { *m = Pipe{} }
func (m *Pipe) String() string            { return proto.CompactTextString(m) }
func (*Pipe) ProtoMessage()               {}
func (*Pipe) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{7} }

type isPipe_Trigger interface {
	isPipe_Trigger()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Pipe_Manual struct {
	Manual *ManualTrigger `protobuf:"bytes,2,opt,name=manual,oneof"`
}
type Pipe_Webhook struct {
	Webhook *WebhookTrigger `protobuf:"bytes,3,opt,name=webhook,oneof"`
}
type Pipe_Cron struct {
	Cron *CronTrigger `protobuf:"bytes,4,opt,name=cron,oneof"`
}

func (*Pipe_Manual) isPipe_Trigger()  {}
func (*Pipe_Webhook) isPipe_Trigger() {}
func (*Pipe_Cron) isPipe_Trigger()    {}

func (m *Pipe) GetTrigger() isPipe_Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *Pipe) GetManual() *ManualTrigger {
	if x, ok := m.GetTrigger().(*Pipe_Manual); ok {
		return x.Manual
	}
	return nil
}

func (m *Pipe) GetWebhook() *WebhookTrigger {
	if x, ok := m.GetTrigger().(*Pipe_Webhook); ok {
		return x.Webhook
	}
	return nil
}

func (m *Pipe) GetCron() *CronTrigger {
	if x, ok := m.GetTrigger().(*Pipe_Cron); ok {
		return x.Cron
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Pipe) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Pipe_OneofMarshaler, _Pipe_OneofUnmarshaler, _Pipe_OneofSizer, []interface{}{
		(*Pipe_Manual)(nil),
		(*Pipe_Webhook)(nil),
		(*Pipe_Cron)(nil),
	}
}

func _Pipe_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Pipe)
	// trigger
	switch x := m.Trigger.(type) {
	case *Pipe_Manual:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Manual); err != nil {
			return err
		}
	case *Pipe_Webhook:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Webhook); err != nil {
			return err
		}
	case *Pipe_Cron:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cron); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Pipe.Trigger has unexpected type %T", x)
	}
	return nil
}

func _Pipe_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Pipe)
	switch tag {
	case 2: // trigger.manual
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ManualTrigger)
		err := b.DecodeMessage(msg)
		m.Trigger = &Pipe_Manual{msg}
		return true, err
	case 3: // trigger.webhook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WebhookTrigger)
		err := b.DecodeMessage(msg)
		m.Trigger = &Pipe_Webhook{msg}
		return true, err
	case 4: // trigger.cron
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CronTrigger)
		err := b.DecodeMessage(msg)
		m.Trigger = &Pipe_Cron{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Pipe_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Pipe)
	// trigger
	switch x := m.Trigger.(type) {
	case *Pipe_Manual:
		s := proto.Size(x.Manual)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Pipe_Webhook:
		s := proto.Size(x.Webhook)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Pipe_Cron:
		s := proto.Size(x.Cron)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PodServiceAction struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Feeds       []Feed `protobuf:"varint,3,rep,name=feeds,enum=otsimo.Feed" json:"feeds,omitempty"`
}

func (m *PodServiceAction) Reset()                    { *m = PodServiceAction{} }
func (m *PodServiceAction) String() string            { return proto.CompactTextString(m) }
func (*PodServiceAction) ProtoMessage()               {}
func (*PodServiceAction) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{8} }

type PodServiceConnection struct {
	Url                   string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Secure                bool   `protobuf:"varint,2,opt,name=secure,proto3" json:"secure,omitempty"`
	InsecureSkipTlsVerify bool   `protobuf:"varint,3,opt,name=insecure_skip_tls_verify,json=insecureSkipTlsVerify,proto3" json:"insecure_skip_tls_verify,omitempty"`
	CertificateAuthority  string `protobuf:"bytes,4,opt,name=certificate_authority,json=certificateAuthority,proto3" json:"certificate_authority,omitempty"`
	ClientCertificate     string `protobuf:"bytes,5,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	ClientKey             string `protobuf:"bytes,6,opt,name=client_key,json=clientKey,proto3" json:"client_key,omitempty"`
	DialTimeout           int32  `protobuf:"varint,7,opt,name=dial_timeout,json=dialTimeout,proto3" json:"dial_timeout,omitempty"`
	BackoffMaxDelay       int32  `protobuf:"varint,8,opt,name=backoff_max_delay,json=backoffMaxDelay,proto3" json:"backoff_max_delay,omitempty"`
}

func (m *PodServiceConnection) Reset()                    { *m = PodServiceConnection{} }
func (m *PodServiceConnection) String() string            { return proto.CompactTextString(m) }
func (*PodServiceConnection) ProtoMessage()               {}
func (*PodServiceConnection) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{9} }

type PodService struct {
	Name        string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description string                `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Connection  *PodServiceConnection `protobuf:"bytes,3,opt,name=connection" json:"connection,omitempty"`
	Actions     []*PodServiceAction   `protobuf:"bytes,4,rep,name=actions" json:"actions,omitempty"`
	Disabled    bool                  `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	CreatedAt   int64                 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt   int64                 `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *PodService) Reset()                    { *m = PodService{} }
func (m *PodService) String() string            { return proto.CompactTextString(m) }
func (*PodService) ProtoMessage()               {}
func (*PodService) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{10} }

// Execution
type Execution struct {
	// ID of this execution
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name of the pipe
	Pipe string `protobuf:"bytes,2,opt,name=pipe,proto3" json:"pipe,omitempty"`
	// State of the execution
	State Execution_State `protobuf:"varint,3,opt,name=state,proto3,enum=otsimo.Execution_State" json:"state,omitempty"`
	// When this execution is started
	StartedAt int64 `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// When last time state changed
	StateChangedAt int64 `protobuf:"varint,5,opt,name=state_changed_at,json=stateChangedAt,proto3" json:"state_changed_at,omitempty"`
	// Which trigger started the execution
	Trigger string `protobuf:"bytes,6,opt,name=trigger,proto3" json:"trigger,omitempty"`
	// Results are the result of each executed stub
	Results []*Execution_StubExecution `protobuf:"bytes,7,rep,name=results" json:"results,omitempty"`
}

func (m *Execution) Reset()                    { *m = Execution{} }
func (m *Execution) String() string            { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()               {}
func (*Execution) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{11} }

type Execution_StubExecution struct {
	StubName string `protobuf:"bytes,1,opt,name=stub_name,json=stubName,proto3" json:"stub_name,omitempty"`
	Output   string `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *Execution_StubExecution) Reset()                    { *m = Execution_StubExecution{} }
func (m *Execution_StubExecution) String() string            { return proto.CompactTextString(m) }
func (*Execution_StubExecution) ProtoMessage()               {}
func (*Execution_StubExecution) Descriptor() ([]byte, []int) { return fileDescriptorFlow, []int{11, 0} }

func init() {
	proto.RegisterType((*FlowIn)(nil), "otsimo.FlowIn")
	proto.RegisterType((*FlowOut)(nil), "otsimo.FlowOut")
	proto.RegisterType((*Link)(nil), "otsimo.Link")
	proto.RegisterType((*Stub)(nil), "otsimo.Stub")
	proto.RegisterType((*ManualTrigger)(nil), "otsimo.ManualTrigger")
	proto.RegisterType((*WebhookTrigger)(nil), "otsimo.WebhookTrigger")
	proto.RegisterType((*CronTrigger)(nil), "otsimo.CronTrigger")
	proto.RegisterType((*Pipe)(nil), "otsimo.Pipe")
	proto.RegisterType((*PodServiceAction)(nil), "otsimo.PodServiceAction")
	proto.RegisterType((*PodServiceConnection)(nil), "otsimo.PodServiceConnection")
	proto.RegisterType((*PodService)(nil), "otsimo.PodService")
	proto.RegisterType((*Execution)(nil), "otsimo.Execution")
	proto.RegisterType((*Execution_StubExecution)(nil), "otsimo.Execution.StubExecution")
	proto.RegisterEnum("otsimo.Feed", Feed_name, Feed_value)
	proto.RegisterEnum("otsimo.Link_Kind", Link_Kind_name, Link_Kind_value)
	proto.RegisterEnum("otsimo.Execution_State", Execution_State_name, Execution_State_value)
}
func (m *FlowIn) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FlowIn) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Payload)))
		i += copy(data[i:], m.Payload)
	}
	if m.Data != nil {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Ids) > 0 {
		for k, _ := range m.Ids {
			data[i] = 0x1a
			i++
			v := m.Ids[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFlow(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintFlow(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Config) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Config)))
		i += copy(data[i:], m.Config)
	}
	if len(m.Action) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Action)))
		i += copy(data[i:], m.Action)
	}
	if m.TimestampNano != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFlow(data, i, uint64(m.TimestampNano))
	}
	return i, nil
}

func (m *FlowOut) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FlowOut) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Payload)))
		i += copy(data[i:], m.Payload)
	}
	if m.Data != nil {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(m.Data.Size()))
		n2, err := m.Data.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Ids) > 0 {
		for k, _ := range m.Ids {
			data[i] = 0x1a
			i++
			v := m.Ids[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFlow(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintFlow(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Link) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Link) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintFlow(data, i, uint64(m.Kind))
	}
	if len(m.Script) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Script)))
		i += copy(data[i:], m.Script)
	}
	if len(m.LinksFrom) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.LinksFrom)))
		i += copy(data[i:], m.LinksFrom)
	}
	return i, nil
}

func (m *Stub) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Stub) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StubName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.StubName)))
		i += copy(data[i:], m.StubName)
	}
	if len(m.ServiceName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.ServiceName)))
		i += copy(data[i:], m.ServiceName)
	}
	if len(m.ServiceAction) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.ServiceAction)))
		i += copy(data[i:], m.ServiceAction)
	}
	if len(m.Config) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Config)))
		i += copy(data[i:], m.Config)
	}
	if m.Feed != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintFlow(data, i, uint64(m.Feed))
	}
	if m.Link != nil {
		data[i] = 0x32
		i++
		i = encodeVarintFlow(data, i, uint64(m.Link.Size()))
		n3, err := m.Link.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ManualTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ManualTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WebhookTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WebhookTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CronTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CronTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schedule) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Schedule)))
		i += copy(data[i:], m.Schedule)
	}
	return i, nil
}

func (m *Pipe) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Pipe) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Trigger != nil {
		nn4, err := m.Trigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.SuccessCount != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFlow(data, i, uint64(m.SuccessCount))
	}
	if m.ErrorCount != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintFlow(data, i, uint64(m.ErrorCount))
	}
	if m.Disabled {
		data[i] = 0x40
		i++
		if m.Disabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Stubs) > 0 {
		for _, msg := range m.Stubs {
			data[i] = 0x4a
			i++
			i = encodeVarintFlow(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreatedAt != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintFlow(data, i, uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintFlow(data, i, uint64(m.UpdatedAt))
	}
	return i, nil
}

func (m *Pipe_Manual) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Manual != nil {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(m.Manual.Size()))
		n5, err := m.Manual.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Pipe_Webhook) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Webhook != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFlow(data, i, uint64(m.Webhook.Size()))
		n6, err := m.Webhook.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Pipe_Cron) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Cron != nil {
		data[i] = 0x22
		i++
		i = encodeVarintFlow(data, i, uint64(m.Cron.Size()))
		n7, err := m.Cron.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *PodServiceAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodServiceAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Feeds) > 0 {
		for _, num := range m.Feeds {
			data[i] = 0x18
			i++
			i = encodeVarintFlow(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *PodServiceConnection) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodServiceConnection) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Url)))
		i += copy(data[i:], m.Url)
	}
	if m.Secure {
		data[i] = 0x10
		i++
		if m.Secure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.InsecureSkipTlsVerify {
		data[i] = 0x18
		i++
		if m.InsecureSkipTlsVerify {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.CertificateAuthority) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.CertificateAuthority)))
		i += copy(data[i:], m.CertificateAuthority)
	}
	if len(m.ClientCertificate) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.ClientCertificate)))
		i += copy(data[i:], m.ClientCertificate)
	}
	if len(m.ClientKey) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.ClientKey)))
		i += copy(data[i:], m.ClientKey)
	}
	if m.DialTimeout != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintFlow(data, i, uint64(m.DialTimeout))
	}
	if m.BackoffMaxDelay != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintFlow(data, i, uint64(m.BackoffMaxDelay))
	}
	return i, nil
}

func (m *PodService) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodService) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.Connection != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFlow(data, i, uint64(m.Connection.Size()))
		n8, err := m.Connection.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0x22
			i++
			i = encodeVarintFlow(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Disabled {
		data[i] = 0x28
		i++
		if m.Disabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintFlow(data, i, uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintFlow(data, i, uint64(m.UpdatedAt))
	}
	return i, nil
}

func (m *Execution) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Execution) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Pipe) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Pipe)))
		i += copy(data[i:], m.Pipe)
	}
	if m.State != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintFlow(data, i, uint64(m.State))
	}
	if m.StartedAt != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintFlow(data, i, uint64(m.StartedAt))
	}
	if m.StateChangedAt != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintFlow(data, i, uint64(m.StateChangedAt))
	}
	if len(m.Trigger) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Trigger)))
		i += copy(data[i:], m.Trigger)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0x3a
			i++
			i = encodeVarintFlow(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Execution_StubExecution) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Execution_StubExecution) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StubName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.StubName)))
		i += copy(data[i:], m.StubName)
	}
	if len(m.Output) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlow(data, i, uint64(len(m.Output)))
		i += copy(data[i:], m.Output)
	}
	return i, nil
}

func encodeFixed64Flow(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Flow(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFlow(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *FlowIn) Size() (n int) {
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Ids) > 0 {
		for k, v := range m.Ids {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.TimestampNano != 0 {
		n += 1 + sovFlow(uint64(m.TimestampNano))
	}
	return n
}

func (m *FlowOut) Size() (n int) {
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Ids) > 0 {
		for k, v := range m.Ids {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Link) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovFlow(uint64(m.Kind))
	}
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.LinksFrom)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *Stub) Size() (n int) {
	var l int
	_ = l
	l = len(m.StubName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ServiceAction)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Feed != 0 {
		n += 1 + sovFlow(uint64(m.Feed))
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *ManualTrigger) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WebhookTrigger) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CronTrigger) Size() (n int) {
	var l int
	_ = l
	l = len(m.Schedule)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *Pipe) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Trigger != nil {
		n += m.Trigger.Size()
	}
	if m.SuccessCount != 0 {
		n += 1 + sovFlow(uint64(m.SuccessCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovFlow(uint64(m.ErrorCount))
	}
	if m.Disabled {
		n += 2
	}
	if len(m.Stubs) > 0 {
		for _, e := range m.Stubs {
			l = e.Size()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovFlow(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovFlow(uint64(m.UpdatedAt))
	}
	return n
}

func (m *Pipe_Manual) Size() (n int) {
	var l int
	_ = l
	if m.Manual != nil {
		l = m.Manual.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *Pipe_Webhook) Size() (n int) {
	var l int
	_ = l
	if m.Webhook != nil {
		l = m.Webhook.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *Pipe_Cron) Size() (n int) {
	var l int
	_ = l
	if m.Cron != nil {
		l = m.Cron.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}
func (m *PodServiceAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Feeds) > 0 {
		for _, e := range m.Feeds {
			n += 1 + sovFlow(uint64(e))
		}
	}
	return n
}

func (m *PodServiceConnection) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Secure {
		n += 2
	}
	if m.InsecureSkipTlsVerify {
		n += 2
	}
	l = len(m.CertificateAuthority)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ClientKey)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.DialTimeout != 0 {
		n += 1 + sovFlow(uint64(m.DialTimeout))
	}
	if m.BackoffMaxDelay != 0 {
		n += 1 + sovFlow(uint64(m.BackoffMaxDelay))
	}
	return n
}

func (m *PodService) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Connection != nil {
		l = m.Connection.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Disabled {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovFlow(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovFlow(uint64(m.UpdatedAt))
	}
	return n
}

func (m *Execution) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Pipe)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovFlow(uint64(m.State))
	}
	if m.StartedAt != 0 {
		n += 1 + sovFlow(uint64(m.StartedAt))
	}
	if m.StateChangedAt != 0 {
		n += 1 + sovFlow(uint64(m.StateChangedAt))
	}
	l = len(m.Trigger)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	return n
}

func (m *Execution_StubExecution) Size() (n int) {
	var l int
	_ = l
	l = len(m.StubName)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func sovFlow(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowIn) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], data[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &apipb.DataSet{}
			}
			if err := m.Data.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFlow
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Ids == nil {
				m.Ids = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthFlow
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Ids[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Ids[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], data[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNano", wireType)
			}
			m.TimestampNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampNano |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowOut) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], data[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &apipb.DataSet{}
			}
			if err := m.Data.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFlow
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Ids == nil {
				m.Ids = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthFlow
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Ids[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Ids[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (Link_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = append(m.Script[:0], data[iNdEx:postIndex]...)
			if m.Script == nil {
				m.Script = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinksFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinksFrom = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stub) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StubName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StubName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], data[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			m.Feed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Feed |= (Feed(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebhookTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebhookTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebhookTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schedule = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipe) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ManualTrigger{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &Pipe_Manual{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webhook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WebhookTrigger{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &Pipe_Webhook{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CronTrigger{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &Pipe_Cron{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessCount", wireType)
			}
			m.SuccessCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SuccessCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stubs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stubs = append(m.Stubs, &Stub{})
			if err := m.Stubs[len(m.Stubs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodServiceAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodServiceAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodServiceAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feeds", wireType)
			}
			var v Feed
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Feed(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Feeds = append(m.Feeds, v)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodServiceConnection) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodServiceConnection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodServiceConnection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipTlsVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsecureSkipTlsVerify = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateAuthority = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialTimeout", wireType)
			}
			m.DialTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DialTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackoffMaxDelay", wireType)
			}
			m.BackoffMaxDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BackoffMaxDelay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodService) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connection == nil {
				m.Connection = &PodServiceConnection{}
			}
			if err := m.Connection.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &PodServiceAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pipe = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (Execution_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateChangedAt", wireType)
			}
			m.StateChangedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StateChangedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trigger = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &Execution_StubExecution{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution_StubExecution) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StubExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StubExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StubName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StubName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlow(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlow = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("flow.proto", fileDescriptorFlow) }

var fileDescriptorFlow = []byte{
	// 1230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x8f, 0x1a, 0x47,
	0x13, 0x66, 0xf8, 0xa6, 0xd8, 0xc5, 0xb8, 0x5f, 0xdb, 0xef, 0x68, 0x93, 0x60, 0x32, 0x91, 0x25,
	0xd6, 0x92, 0x59, 0x09, 0x4b, 0xf9, 0x52, 0x0e, 0xc1, 0x2c, 0x6b, 0x23, 0xaf, 0xd9, 0x55, 0x83,
	0x13, 0x29, 0x97, 0x51, 0x33, 0xd3, 0xb0, 0x2d, 0x86, 0xe9, 0xd1, 0x4c, 0x8f, 0x6d, 0x6e, 0x39,
	0xf8, 0x1c, 0xe5, 0x98, 0xff, 0x90, 0x3f, 0xe2, 0x28, 0x17, 0xff, 0x84, 0xd8, 0xfe, 0x15, 0xb9,
	0x45, 0xfd, 0x31, 0x2c, 0xac, 0x1c, 0x1f, 0x9c, 0x13, 0x5d, 0xf5, 0x3c, 0xd3, 0x55, 0x5d, 0xf5,
	0x54, 0x37, 0x00, 0xf3, 0x80, 0x3f, 0xef, 0x46, 0x31, 0x17, 0x1c, 0x95, 0xb9, 0x48, 0xd8, 0x8a,
	0x1f, 0xdc, 0x5b, 0x30, 0x71, 0x91, 0xce, 0xba, 0x1e, 0x5f, 0x1d, 0x2d, 0xf8, 0x82, 0x1f, 0x29,
	0x78, 0x96, 0xce, 0x95, 0xa5, 0x0c, 0xb5, 0xd2, 0x9f, 0x1d, 0x74, 0xb7, 0xe8, 0x7a, 0x07, 0xf3,
	0x13, 0xcd, 0x8e, 0x7c, 0x22, 0x48, 0x42, 0xc5, 0x8a, 0xfb, 0x34, 0x48, 0x34, 0xdf, 0xf9, 0x39,
	0x0f, 0xe5, 0x93, 0x80, 0x3f, 0x1f, 0x85, 0xc8, 0x86, 0x4a, 0x44, 0xd6, 0x01, 0x27, 0xbe, 0x6d,
	0xb5, 0xad, 0xce, 0x1e, 0xce, 0x4c, 0xe4, 0x40, 0x51, 0x7e, 0x6b, 0xe7, 0xdb, 0x56, 0xa7, 0xde,
	0x6b, 0x74, 0x49, 0xc4, 0xa2, 0x59, 0xf7, 0x98, 0x08, 0x32, 0xa1, 0x02, 0x2b, 0x0c, 0x1d, 0x42,
	0x81, 0xf9, 0x89, 0x5d, 0x68, 0x17, 0x3a, 0xf5, 0xde, 0xff, 0xbb, 0x3a, 0x68, 0x57, 0x6f, 0xdd,
	0x1d, 0xf9, 0xc9, 0x30, 0x14, 0xf1, 0x1a, 0x4b, 0x0e, 0xba, 0x05, 0x65, 0x8f, 0x87, 0x73, 0xb6,
	0xb0, 0x8b, 0x2a, 0x8e, 0xb1, 0xa4, 0x9f, 0x78, 0x82, 0xf1, 0xd0, 0x2e, 0xb5, 0xad, 0x4e, 0x0d,
	0x1b, 0x0b, 0xdd, 0x81, 0x86, 0x60, 0x2b, 0x9a, 0x08, 0xb2, 0x8a, 0xdc, 0x90, 0x84, 0xdc, 0x2e,
	0xb7, 0xad, 0x4e, 0x01, 0xef, 0x6f, 0xbc, 0x63, 0x12, 0xf2, 0x83, 0x2f, 0xa1, 0x9a, 0xc5, 0x41,
	0x4d, 0x28, 0x2c, 0xe9, 0x5a, 0x9d, 0xa3, 0x86, 0xe5, 0x12, 0xdd, 0x80, 0xd2, 0x33, 0x12, 0xa4,
	0x54, 0x1d, 0xa2, 0x86, 0xb5, 0xf1, 0x6d, 0xfe, 0x6b, 0xcb, 0xf9, 0xdd, 0x82, 0x8a, 0xcc, 0xf3,
	0x2c, 0x15, 0xff, 0xb1, 0x06, 0x77, 0xb7, 0x6b, 0x60, 0x6f, 0xd7, 0xe0, 0x2c, 0x15, 0xbb, 0x45,
	0xf8, 0xe8, 0x6c, 0x5f, 0x5a, 0x50, 0x3c, 0x65, 0xe1, 0x12, 0xdd, 0x81, 0xe2, 0x92, 0x85, 0x3a,
	0xcf, 0x46, 0xef, 0x7a, 0x16, 0x4d, 0x62, 0xdd, 0xc7, 0x2c, 0xf4, 0xb1, 0x82, 0x65, 0x51, 0x13,
	0x2f, 0x66, 0x91, 0x50, 0x5b, 0xed, 0x61, 0x63, 0xa1, 0xcf, 0x00, 0x02, 0x16, 0x2e, 0x13, 0x77,
	0x1e, 0xf3, 0x95, 0x5d, 0x50, 0x61, 0x6a, 0xca, 0x73, 0x12, 0xf3, 0x95, 0xd3, 0x82, 0xa2, 0xdc,
	0x04, 0x01, 0x94, 0x8f, 0x47, 0x78, 0x38, 0x98, 0x36, 0x73, 0x72, 0x3d, 0x19, 0xe0, 0xd1, 0xf9,
	0xb4, 0x69, 0x39, 0x7f, 0x58, 0x50, 0x9c, 0x88, 0x74, 0x86, 0x3e, 0x81, 0x5a, 0x22, 0xd2, 0x99,
	0x1b, 0x92, 0x15, 0x35, 0x27, 0xa8, 0x4a, 0xc7, 0x98, 0xac, 0x28, 0xfa, 0x1c, 0xf6, 0x12, 0x1a,
	0x3f, 0x63, 0x1e, 0xd5, 0xb8, 0x3e, 0x4d, 0xdd, 0xf8, 0x14, 0xe5, 0x0e, 0x34, 0x32, 0x8a, 0x69,
	0xbe, 0xce, 0x65, 0xdf, 0x78, 0xfb, 0x5a, 0x03, 0xff, 0xa6, 0x99, 0x36, 0x14, 0xe7, 0x94, 0xfa,
	0x4a, 0x31, 0x8d, 0xde, 0xde, 0xa6, 0xe6, 0x94, 0xfa, 0x58, 0x21, 0x92, 0x21, 0x8f, 0xa5, 0x34,
	0x53, 0xbf, 0x64, 0xc8, 0x3a, 0x61, 0x85, 0x38, 0xd7, 0x60, 0xff, 0x09, 0x09, 0x53, 0x12, 0x4c,
	0x63, 0xb6, 0x58, 0xd0, 0xd8, 0x69, 0x42, 0xe3, 0x47, 0x3a, 0xbb, 0xe0, 0x7c, 0x99, 0x79, 0x0e,
	0xa1, 0x3e, 0x88, 0x79, 0x68, 0x4c, 0x74, 0x00, 0xd5, 0xc4, 0xbb, 0xa0, 0x7e, 0x1a, 0x5c, 0x9e,
	0xd9, 0xd8, 0xce, 0xdf, 0x79, 0x28, 0x9e, 0xb3, 0x88, 0x22, 0x04, 0xc5, 0xad, 0xa2, 0xa8, 0x35,
	0x3a, 0x82, 0xf2, 0x4a, 0x85, 0x32, 0x3a, 0xba, 0x99, 0xa5, 0xb3, 0x93, 0xc0, 0xa3, 0x1c, 0x36,
	0x34, 0xd4, 0x83, 0xca, 0x73, 0x9d, 0x8a, 0xaa, 0x4b, 0xbd, 0x77, 0x2b, 0xfb, 0x62, 0x37, 0xc3,
	0x47, 0x39, 0x9c, 0x11, 0xd1, 0x21, 0x14, 0xbd, 0x98, 0x87, 0xaa, 0x52, 0xf5, 0xde, 0xff, 0xb2,
	0x0f, 0xb6, 0x0e, 0xf0, 0x28, 0x87, 0x15, 0x05, 0x7d, 0x01, 0xfb, 0x49, 0xea, 0x79, 0x34, 0x49,
	0x5c, 0x8f, 0xa7, 0xa1, 0x50, 0x55, 0x2a, 0xe1, 0x3d, 0xe3, 0x1c, 0x48, 0x1f, 0xba, 0x0d, 0x75,
	0x1a, 0xc7, 0x3c, 0x36, 0x94, 0x8a, 0xa2, 0x80, 0x72, 0x69, 0xc2, 0x01, 0x54, 0x7d, 0x96, 0x90,
	0x59, 0x40, 0x7d, 0xbb, 0xda, 0xb6, 0x3a, 0x55, 0xbc, 0xb1, 0x91, 0x03, 0x25, 0x29, 0x87, 0xc4,
	0xae, 0xa9, 0xa9, 0xd8, 0xd4, 0x5f, 0x8a, 0x07, 0x6b, 0x48, 0x6a, 0xd1, 0x8b, 0x29, 0x11, 0xd4,
	0x77, 0x89, 0xb0, 0x41, 0x0d, 0x77, 0xcd, 0x78, 0xfa, 0x4a, 0xaa, 0x69, 0xe4, 0x67, 0x70, 0x5d,
	0xc3, 0xc6, 0xd3, 0x17, 0x0f, 0x6a, 0x50, 0x11, 0xa6, 0x4d, 0x01, 0x34, 0xcf, 0xb9, 0x3f, 0xd9,
	0x51, 0xce, 0xfb, 0xda, 0xd0, 0x86, 0xba, 0x4f, 0xf5, 0x20, 0x48, 0xc5, 0x19, 0x59, 0x6e, 0xb9,
	0x64, 0xda, 0x52, 0x3d, 0x7a, 0x98, 0xaf, 0x0a, 0x4b, 0x43, 0xce, 0x9f, 0x79, 0xb8, 0x71, 0x19,
	0x6e, 0xc0, 0xc3, 0x90, 0xea, 0x90, 0x4d, 0x28, 0xa4, 0x71, 0x90, 0xcd, 0x73, 0x1a, 0x07, 0x6a,
	0x0a, 0xa9, 0x97, 0xc6, 0x7a, 0x04, 0xaa, 0xd8, 0x58, 0xe8, 0x2b, 0xb0, 0x59, 0xa8, 0xd7, 0x6e,
	0xb2, 0x64, 0x91, 0x2b, 0x82, 0xc4, 0x7d, 0x46, 0x63, 0x36, 0x5f, 0xab, 0x7e, 0x57, 0xf1, 0xcd,
	0x0c, 0x9f, 0x2c, 0x59, 0x34, 0x0d, 0x92, 0x1f, 0x14, 0x88, 0xee, 0xc3, 0x4d, 0x8f, 0xc6, 0x82,
	0xcd, 0x99, 0x47, 0x04, 0x75, 0x49, 0x2a, 0x2e, 0x78, 0xcc, 0xc4, 0x5a, 0x35, 0xbd, 0x86, 0x6f,
	0x6c, 0x81, 0xfd, 0x0c, 0x43, 0xf7, 0x00, 0x79, 0x01, 0xa3, 0xa1, 0x70, 0xb7, 0x60, 0x73, 0xd9,
	0x5e, 0xd7, 0xc8, 0xe0, 0x12, 0x50, 0x6d, 0xd1, 0x74, 0x79, 0x3b, 0x95, 0xf5, 0x15, 0xa1, 0x3d,
	0x8f, 0xe9, 0x5a, 0x0e, 0xb7, 0xcf, 0x48, 0xe0, 0xca, 0x5b, 0x98, 0xa7, 0x99, 0x2e, 0xea, 0xd2,
	0x37, 0xd5, 0x2e, 0x74, 0x17, 0xae, 0xcf, 0x88, 0xb7, 0xe4, 0xf3, 0xb9, 0xbb, 0x22, 0x2f, 0x5c,
	0x9f, 0x06, 0x64, 0xad, 0x14, 0x52, 0xc2, 0xd7, 0x0c, 0xf0, 0x84, 0xbc, 0x38, 0x96, 0x6e, 0xe7,
	0x97, 0x3c, 0xc0, 0x65, 0x35, 0x3f, 0xb2, 0x6d, 0xdf, 0x01, 0x78, 0x9b, 0x3e, 0x98, 0x89, 0xf9,
	0x34, 0xeb, 0xdd, 0xfb, 0x7a, 0x85, 0xb7, 0xf8, 0x72, 0xd8, 0xf4, 0x1d, 0x94, 0xd8, 0xc5, 0xdd,
	0x3b, 0xfc, 0xaa, 0xaa, 0x70, 0x46, 0xdc, 0xd1, 0x7e, 0xe9, 0x8a, 0xf6, 0x77, 0x75, 0x5d, 0xfe,
	0xb0, 0xae, 0x2b, 0x57, 0x74, 0xed, 0xbc, 0x2c, 0x40, 0x6d, 0xf8, 0x82, 0x7a, 0xa9, 0xca, 0xad,
	0x01, 0x79, 0xe6, 0x9b, 0x6a, 0xe4, 0x99, 0x2f, 0xeb, 0x13, 0xb1, 0x28, 0xbb, 0x52, 0xd5, 0x1a,
	0xdd, 0x93, 0xb3, 0x26, 0x5b, 0x5a, 0x50, 0xb7, 0xe1, 0xe6, 0x15, 0xde, 0xec, 0xd2, 0x9d, 0x48,
	0x18, 0x6b, 0x96, 0x8c, 0x9f, 0x08, 0x12, 0x9b, 0xf8, 0x45, 0x1d, 0xdf, 0x78, 0xfa, 0x02, 0x75,
	0xa0, 0xa9, 0x78, 0xae, 0x77, 0x41, 0xc2, 0x85, 0x26, 0x95, 0x14, 0xa9, 0xa1, 0xfc, 0x03, 0xed,
	0xee, 0xab, 0x57, 0xd3, 0x4c, 0xa0, 0x51, 0x49, 0x66, 0xa2, 0x6f, 0xa0, 0x12, 0xd3, 0x24, 0x0d,
	0x44, 0x62, 0x57, 0x54, 0x45, 0x6f, 0xbf, 0x2f, 0xa7, 0x74, 0xb6, 0xb1, 0x70, 0xc6, 0x3f, 0x38,
	0x86, 0xfd, 0x1d, 0xe4, 0xc3, 0x2f, 0xcd, 0x2d, 0x28, 0xf3, 0x54, 0x44, 0xa9, 0x30, 0x05, 0x31,
	0x96, 0xf3, 0x3d, 0x94, 0xd4, 0x99, 0xd1, 0x35, 0xa8, 0x8f, 0xcf, 0xa6, 0xee, 0x64, 0xda, 0xc7,
	0xd3, 0xe1, 0x71, 0x33, 0x87, 0xea, 0x50, 0xc1, 0x4f, 0xc7, 0xe3, 0xd1, 0xf8, 0x61, 0xd3, 0x42,
	0xfb, 0x50, 0x1b, 0x9c, 0x3d, 0x39, 0x3f, 0x1d, 0x4a, 0x2c, 0x2f, 0x5f, 0xba, 0x93, 0xfe, 0xe8,
	0x74, 0x78, 0xdc, 0x2c, 0xdc, 0x3d, 0x84, 0xa2, 0x1c, 0x7a, 0xf5, 0xfa, 0x8d, 0xc6, 0x0f, 0x4f,
	0x87, 0xfa, 0x25, 0x3c, 0xe9, 0x8f, 0xcf, 0x9e, 0x4e, 0x9b, 0x16, 0xaa, 0x41, 0xe9, 0xa4, 0x3f,
	0x1e, 0x8d, 0x9b, 0xf9, 0x07, 0x9d, 0x57, 0x6f, 0x5a, 0xb9, 0xd7, 0x6f, 0x5a, 0xd6, 0xab, 0xb7,
	0x2d, 0xeb, 0xf5, 0xdb, 0x96, 0xf5, 0xd7, 0xdb, 0x96, 0xf5, 0xeb, 0xbb, 0x56, 0xee, 0xb7, 0x77,
	0xad, 0xdc, 0x4f, 0x20, 0x7b, 0x14, 0xb0, 0x90, 0x46, 0xb3, 0x59, 0x59, 0xfd, 0xfb, 0xba, 0xff,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x57, 0x0d, 0xc4, 0x68, 0xf2, 0x09, 0x00, 0x00,
}
